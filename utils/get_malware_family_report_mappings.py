import argparse
import json
import glob
import os

def parse_arguments():
    parser = argparse.ArgumentParser(description="Visualize results from get_stats.py")
    parser.add_argument("json_dir", help="The directory containing report files, as generated by MALVADA.")
    # parser.add_argument("--fig_title", help="(Optional) Specify the title of the generated figure. By default it is empty.")
    # parser.add_argument("--level", help="Specifies the desired behavioral catalog level for which the figure will be generated.", choices=["micro-objective", "micro-behavior"], required=True)
    arguments = parser.parse_args()
    return arguments

if __name__ == "__main__":
    arguments = parse_arguments()

    file_list = glob.glob(arguments.json_dir + "/*.json")

    cape_labels = {}
    cape_n_reports = 0

    avclass_labels = {}
    avclass_n_reports = 0

    for file in file_list:
        with open(file) as f:
            try:
                data = json.load(f)
            except Exception as e:
                print(f"Error parsing file {file}. Skipping it!")
                continue

            report_name = os.path.basename(file)

            # Create common info to both entries
            common_entry = {}
            common_entry["md5"] = data["target"]["file"]["md5"]
            common_entry["sha1"] = data["target"]["file"]["sha1"]
            common_entry["sha256"] = data["target"]["file"]["sha256"]
            common_entry["SHA512"] = data["target"]["file"]["sha512"]
            common_entry["ssdeep"] = data["target"]["file"]["ssdeep"]
            common_entry["tlsh"] = data["target"]["file"]["tlsh"]
            common_entry["sha3_384"] = data["target"]["file"]["sha3_384"]

            # Retrieve labels
            avclass_label = data["avclass_detection"].capitalize()
            cape_label = data["detections"][0]["family"].capitalize() if data["detections"] != "(n/a)" else "(n/a)"

            # Create the entries if they do not exist already
            if avclass_label not in avclass_labels:
                avclass_labels[avclass_label] = {}
                avclass_labels[avclass_label]["n_reports"] = 0
                avclass_labels[avclass_label]["reports"] = []
            if cape_label not in cape_labels:
                cape_labels[cape_label] = {}
                cape_labels[cape_label]["n_reports"] = 0
                cape_labels[cape_label]["reports"] = []

            # AVClass specifics
            avclass_entry = {}
            avclass_entry["report"] = report_name
            avclass_entry.update(common_entry)
            avclass_labels[avclass_label]["n_reports"] += 1
            avclass_labels[avclass_label]["reports"].append(avclass_entry)
            avclass_n_reports += 1

            # CAPE specifics
            cape_entry = {}
            cape_entry["report"] = report_name
            cape_entry.update(common_entry)
            cape_labels[cape_label]["n_reports"] += 1
            cape_labels[cape_label]["reports"].append(cape_entry)
            cape_n_reports += 1

    ##### End of for

    # Sorts dicts in descending order, based on n_reports
    avclass_labels = dict(sorted(avclass_labels.items(), key=lambda item: item[1]["n_reports"], reverse=True))
    cape_labels = dict(sorted(cape_labels.items(), key=lambda item: item[1]["n_reports"], reverse=True))

    new_avclass_dict = {"n_reports":avclass_n_reports}
    new_avclass_dict.update(avclass_labels)

    with open("avclass_report_to_label_mapping.json", "w") as file:
        json.dump(new_avclass_dict, file, indent=4)

    new_cape_dict = {"n_reports":cape_n_reports}
    new_cape_dict.update(cape_labels)

    with open("cape_report_to_label_mapping.json", "w") as file:
        json.dump(new_cape_dict, file, indent=4)