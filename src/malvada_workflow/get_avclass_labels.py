import argparse
import json
import glob
import subprocess
import os
import concurrent.futures
from rich.progress import (
    BarColumn,
    Progress,
    TextColumn,
    TimeRemainingColumn,
    SpinnerColumn,
    TaskProgressColumn,
    TimeElapsedColumn,
)

TMP_FILE = 'tmp/AVClass_labeling'


def parse_arguments():
    """
    Arguments parsing.
    """
    parser = argparse.ArgumentParser(
        description="Traverse a directory of reports.json so as to retrieve the needed information"
        "to produce a file in the correct format to feed AVClass with. Then feed AVClass with the file,"
        "retrieve the output and place the AVClass consensus result in the ['avclass_detection']"
        "field from the CAPE report (creating the field at the root level of the JSON object)."
        "Correct installation of AVClass is assumed.")
    parser.add_argument("json_dir", help="The directory containing the json report files.")
    parser.add_argument("-s", "--silent", action="store_true", help="Silent mode.")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Number of workers to use.")
    arguments = parser.parse_args()
    return arguments


def run_avclass(file: str) -> tuple:
    """
    Runs AVClass as a subprocess and parses its output. Assumes AVClass correct installation.

    Args:
        file: The file to pass to AVClass.

    Returns:
        A tuple containing a boolean (True for success) and a string (output/error message).
    """
    try:
        # Capture output and potential errors using 'capture_output'
        result = subprocess.run(["avclass", "-f", file], capture_output=True, text=True)
        # Check the return code (0 indicates success)
        if result.returncode == 0:
            return True, result.stdout
        else:
            # Raise an exception with the error message
            raise subprocess.CalledProcessError(
                result.returncode, ["avclass", "-f", file], result.stderr)
    except subprocess.CalledProcessError as error:
        # Handle the error case, provide informative message
        return False, f"Error running command: {error.cmd}\nError message: {error.stderr}"


def process_file(json_file: str) -> None:
    """
    Takes a json file and creates an AVClass label for it. The function assumes the file is a correct JSON object.
    The label is placed (in-place modification) in the ['avclass_detection'] field of the JSON object.

    Warning:
        The function modifies the original file.

    Args:
        json_file: A CAPE report to process.
    """

    tmp_file = TMP_FILE + '_' + json_file.split('/')[-1]

    # Retrieve the data from the report (generated by CAPE)
    json_object = {}
    data = {}

    with open(json_file) as f:
        data = json.load(f)
    json_object['md5'] = data['target']['file']['md5']
    json_object['sha1'] = data['target']['file']['sha1']
    json_object['sha256'] = data['target']['file']['sha256']
    json_object['av_labels'] = []
    for scan_result in data['target']['file']['virustotal']['results']:
        json_object['av_labels'].append([scan_result['vendor'], scan_result['sig']])

    # Write vendors + results in AVClass format to a temporal file
    with open(tmp_file, "x") as file:
        json.dump(json_object, file)

    # Invoke AVClass passing the temporal file as input and retrieve the output
    succ, output = run_avclass(tmp_file)

    if succ:
        # Output is in the form: hash      label
        # So we .split() it and take the second argument
        # If the AVClass label contains "SINGLETON", there was no consensus. Otherwise, place the label per se
        avclass_label = output.split()[1] if "SINGLETON" not in output.split()[1] else "(n/a)"
        data['avclass_detection'] = avclass_label.capitalize()
    else:
        print(f"[!!] Error processing {json_file}: {output}")  # Shouldn't happen
        exit()

    # Re-write (update) original report file
    try:
        with open(json_file, "w") as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print("[!!] Error adding AVClass label to {json_file}:\n\t"
              f"{e} - {e.strerror}.\n[!!] Skipping. MALVADA continues.")

    # Remove temporal file
    os.remove(tmp_file)


def main(json_files: list, silent: bool, progress: Progress, workers: int = 10) -> None:
    """
    Main function, runs the AVClass analysis concurrently, using the number of workers provided.

    Args:
        json_files: List of JSON files to process.
        silent: If True, no output will be printed.
        progress: rich.progress.Progress object to show the processing status.
        workers: Number of workers to use (Default: 10).
    """

    total_files = len(json_files)

    if not silent:
        progress.console.rule(
            "[bold dark_turquoise]Phase 4: AVClass labeling", style="dark_turquoise")

    # Check that AVClass is installed
    try:
        subprocess.run(["avclass", "-h"], capture_output=True, text=True)
        if not silent:
            progress.console.log("[+] [dark_turquoise]AVClass[/dark_turquoise] is installed.")
    except FileNotFoundError:
        progress.console.log(
            "[!] Error: AVClass is not installed. Please install it and make sure it is in your PATH.")
        exit()

    # Create tmp folder
    os.makedirs('tmp', exist_ok=True)

    if not silent:
        task = progress.add_task("[dark_turquoise]AVClass labeling", total=total_files)
        progress.start_task(task)

    # Process files in parallel
    with concurrent.futures.ProcessPoolExecutor(max_workers=workers) as executor:
        results = []
        for json_file in json_files:
            results.append(executor.submit(process_file, json_file))
        for f in concurrent.futures.as_completed(results):
            progress.update(task, advance=1) if not silent else None

    # Delete tmp folder
    try:
        os.rmdir('tmp')
    except Exception as e:
        print("[!!] Error deleting 'tmp' directory:\n\t"
              f"{e} - {e.strerror}.\n[!!] Keeping the directory. MALVADA continues.")

    if not silent:
        progress.stop_task(task)
        progress.console.rule("[bold dark_turquoise]End of Phase 4", style="dark_turquoise")


if __name__ == "__main__":
    """
    If this script is executed directly (and not as part of the pipeline),
    it will parse the arguments and execute the `main()` function.
    """
    args = parse_arguments()
    progress = Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        "•",
        TimeElapsedColumn(),
        "•",
        TimeRemainingColumn(),
    )

    if not args.silent:
        progress.start()
        progress.console.rule("[bold green]MALVADA", style="green")

    reports = glob.glob(args.json_dir+"/*.json")

    # Check if there are no reports within the directory
    if not len(reports):
        progress.console.log("Error: No reports found.")
        progress.stop()
        exit()

    main(reports, args.silent, progress, args.workers)
    if not args.silent:
        progress.console.rule("[bold green]MALVADA", style="green")
        progress.stop()
